# -*- coding: utf-8 -*-
"""corona.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tpQ5yPT1BZtBUE6CJoF21KLNkbeyjrKk

***Disclaimer: The methods and techniques used in this post are meant for educational purposes only. This is not a scientifically rigorous study.***

***Remember that these datasets are updated at the end of each day. So, we are almost one day behind.***

Read the confirmed data from the following link.
This dataset contains the number of confirmed cases for each country and in different days
"""

import pandas as pd
import numpy as np
import plotly.graph_objects as go

urlc = 'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Confirmed.csv'

confirmed = pd.read_csv(urlc, error_bad_lines=False)

"""## Change the name of the first two columns to 'State' and 'Country' (It is just easier)"""

confirmed.columns=pd.Series(confirmed.columns).replace(['Province/State','Country/Region'],['state','country'])

"""Get the first three rows from confirmed dataset (just to see how it looks liike)"""

confirmed.head(3).style.background_gradient(cmap='plasma')

""".. . 

1. Each row is about a state (city)
2. In some rows, the states are not recorded (103 rows)
3. Not all countries have information about the states
4. The third and fouurth columns are the latitude and longitude of the states
5. Rest of columns are dates
"""

np.sum(confirmed.isna())

"""Since we would like to work with countries and not the states, we need to pull all the information about each country in a single row. That is why we are grouping the dataframe based on the varable 'country'. The first four columns will be deleted afterwards."""

confirmed=confirmed.groupby('country').sum().iloc[:,2:]
confirmed.head(10).style.background_gradient(cmap='plasma')

print('As of "{}", {} countries are dealing with corona virus.'.format(pd.Timestamp('3/10/2020').now(),confirmed.shape[0]))

"""Number of confirmed cases in each country"""

confirmed.agg('max',axis=1)

"""Get the countries with more than 100 confirmed cases"""

n_confirmed=confirmed.agg('max',axis=1)
y=n_confirmed.loc[n_confirmed>100]
x=n_confirmed.index[n_confirmed>100]

"""Use plotly library to draw a barplot for confirmed cases. Hover on the bars (put your mouse cusrsor on the bars) to see more details. In plotly, you can zoom in and out as you like. You can move the bars across the axes. It is awesome!"""

fig = go.Figure(go.Bar(hoverinfo=None,x=x,y=y,hovertext=['{} % of cases'.format(np.round(y.iloc[co]/np.sum(y)*100,2)) for co in range(len(x))]))
fig.update_traces(marker_color='rgb(126,2,114)', marker_line_color='rgb(254,170,228)',
                  marker_line_width=2.5, opacity=0.5)
fig.update_layout(title_text='Confirmed cases: Countries with more than 100 cases')
fig.show()

"""Read the death data from the following link and perform the same preprocessing steps which we did for the confirmed data."""

urld = 'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Deaths.csv'
death = pd.read_csv(urld, error_bad_lines=False)
death.columns=pd.Series(death.columns).replace(['Province/State','Country/Region'],['state','country'])
death=death.groupby('country').sum().iloc[:,2:]

"""Read the recovered data from the following link and perform the necessary preprocessing steps"""

urlr = 'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Recovered.csv'
recover = pd.read_csv(urlr, error_bad_lines=False)
recover.columns=pd.Series(recover.columns).replace(['Province/State','Country/Region'],['state','country'])
recover=recover.groupby('country').sum().iloc[:,2:]

"""Get the countries with observed deaths, recovered cases and more than 50 confirmed cases"""

n_death=death.agg('max',axis=1)
n_death.drop(index='China',inplace=True)
n_recover=recover.agg('max',axis=1)
n_recover.drop(index='China',inplace=True)
y_d=n_death[(n_death>0) & (n_recover>0) & (n_confirmed>50)]
y_r=n_recover[(n_death>0) & (n_recover>0) & (n_confirmed>50)]
n_confirmed=confirmed.agg('max',axis=1)
n_confirmed.drop(index='China',inplace=True)
y_c=n_confirmed.loc[(n_death>0) & (n_recover>0) & (n_confirmed>50)]

"""Draw a barplot showing confirmed, recovered and death cases except for China (more than 50 confirmed cases)"""

fig = go.Figure(go.Bar(hoverinfo=None,x=y_r.index,y=y_r,name='Recovered',marker_color='rgb(255,186,0)'))
fig.add_trace(go.Bar(x=y_d.index,y=y_d,marker_color='rgb(126,2,114)',name='Death'))
fig.add_trace(go.Bar(x=y_c.index,y=y_c,marker_color='rgb(126,2,250)',name='Confirmed'))
fig.update_layout(barmode='stack',title_text='Deah, recovered and confirmed cases: For countries with more than 50 confirmed cases')
fig.show()

"""Countries with death"""

pd.DataFrame(death.iloc[np.where(death.agg('max',axis=1)>0)[0],-1]).style.background_gradient(cmap='Paired')

"""# New Section

Countries with no death
"""

death.index[death.agg('max',axis=1)==0]

"""Countries with all patients recovered"""

confirmed.index[confirmed.agg('max',axis=1)==recover.agg('max',axis=1)]

"""Countries with confirmed but no recovered and death cases"""

recover.index[(confirmed.agg('max',axis=1)>0) & (recover.agg('max',axis=1)==0) & (death.agg('max',axis=1)==0)]

"""Countries with confirmed and death cases but not recovered"""

confirmed.index[(confirmed.agg('max',axis=1)>0) & (recover.agg('max',axis=1)==0) & (death.agg('max',axis=1)>0)]

"""Overall death rate ***(This is not a good estimate for mortality rate since the epidemc is still going on)***"""

np.sum(death.agg('max',axis=1))/np.sum(confirmed.agg('max',axis=1))*100

"""***The following estimates provide a more accurate estimates for the mortality rate so far (plese refer to https://www.worldometers.info/coronavirus/coronavirus-death-rate/#correct for more information)***"""

np.sum(death.agg('max',axis=1))/(np.sum(recover.agg('max',axis=1))+np.sum(death.agg('max',axis=1)))*100

"""***In the following formula we are assuming that the time difference between confirmation and death is about 14 days on average***"""

np.sum(death.agg('max',axis=1))/np.sum(confirmed.iloc[:,-14])*100

"""Overall recovery rate"""

np.sum(recover.agg('max',axis=1))/np.sum(confirmed.agg('max',axis=1))*100

"""Number of infected patients"""

country='Iran'#you can choose a different country
confirmed_q=confirmed[confirmed.index==country]
recover_q=recover[recover.index==country]
death_q=death[death.index==country]
still_infected=confirmed_q-recover_q-death_q
still_infected

"""Total recovery rate (for a selected country)"""

recover_q.iloc[0].iloc[-1]/confirmed_q.iloc[0].iloc[-1]*100

"""Total death rate (for a selected country)"""

death_q.iloc[0].iloc[-1]/confirmed_q.iloc[0].iloc[-1]*100

death_q.iloc[0].iloc[-1]/confirmed_q.iloc[0].iloc[-14]*100

death_q.iloc[0].iloc[-1]/(death_q.iloc[0].iloc[-1]+recover_q.iloc[0].iloc[-1])*100

"""Plot the confirmed, died and recovered cases in Iran for different days"""

confirmed_Ir=confirmed[confirmed.index=='Iran']
recover_Ir=recover[recover.index=='Iran']
death_Ir=death[death.index=='Iran']
#confirmed_Ir=confirmed[confirmed.index=='Italy']
#recover_Ir=recover[recover.index=='Italy']
#death_Ir=death[death.index=='Italy']

fig = go.Figure()

# Add traces
fig.add_trace(go.Scatter(x=confirmed_Ir.columns[confirmed_Ir.iloc[0]>0], y=confirmed_Ir.iloc[0][confirmed_Ir.iloc[0]>0],
                    mode='lines+markers',
                    name='Confirmed',marker=dict(size=10),marker_color='rgb(126,2,250)',opacity=0.7))
fig.add_trace(go.Scatter(x=recover_Ir.columns[confirmed_Ir.iloc[0]>0], y=recover_Ir.iloc[0][confirmed_Ir.iloc[0]>0],
                    mode='lines+markers',
                    name='Recovered',marker=dict(size=10),opacity=0.7,marker_color='rgb(255,186,0)'))
fig.add_trace(go.Scatter(x=death_Ir.columns[confirmed_Ir.iloc[0]>0], y=death_Ir.iloc[0][confirmed_Ir.iloc[0]>0],
                    mode='lines+markers',
                    name='Died',marker=dict(size=10),opacity=0.7,marker_color='rgb(126,2,114)'))

fig.update_layout(title_text='Deah, recovered and confirmed cases in Iran')

"""Plot the rate of infecton, recovery and death for Iran. Rate here is defined as thet difference between two consecutive days."""

fig = go.Figure()

# Add traces
fig.add_trace(go.Scatter(x=confirmed_Ir.columns[confirmed_Ir.iloc[0]>0], y=confirmed_Ir.iloc[0][confirmed_Ir.iloc[0]>0].diff(1),
                    mode='lines+markers',
                    name='Confirmed',marker=dict(size=10),marker_color='rgb(126,2,250)',opacity=0.7))
fig.add_trace(go.Scatter(x=recover_Ir.columns[confirmed_Ir.iloc[0]>0], y=recover_Ir.iloc[0][confirmed_Ir.iloc[0]>0].diff(1),
                    mode='lines+markers',
                    name='Recovered',marker=dict(size=10),opacity=0.7,marker_color='rgb(255,186,0)'))
fig.add_trace(go.Scatter(x=death_Ir.columns[confirmed_Ir.iloc[0]>0], y=death_Ir.iloc[0][confirmed_Ir.iloc[0]>0].diff(1),
                    mode='lines+markers',
                    name='Died',marker=dict(size=10),opacity=0.7,marker_color='rgb(126,2,114)'))

fig.update_layout(title_text='Deah, recovery and infection rates in Iran')

"""In this section, we would like to take a look at the rate of infection in some counties and have a comparison between 'Iran' and rest of the countries. To do this, we need to see how many days Iran has been dealing with Covid-19; then, we can make a comparison for only these days between Iran and other countries. Note that the number of days is changing, so the plot needs to be updated every day."""

'Compare the first {} days of infection rate for countries with more than {} days of infection'.format(np.sum(confirmed[confirmed.index=='Iran'].iloc[0]>0),np.sum(confirmed[confirmed.index=='Iran'].iloc[0]>0))

'First, we need to find countries with more than {} days of infection'.format(np.sum(confirmed[confirmed.index=='Iran'].iloc[0]>0))

#This function gives us the number days of infection for each country x 
def countdays(x):
    return(np.sum(confirmed[confirmed.index==x].iloc[0]>0))

#Compute the days of infection for all countries
count=pd.Series(confirmed.index).agg(countdays)

Iran_days_infection=np.sum(confirmed[confirmed.index=='Iran'].iloc[0]>0)
#Get the countries except for China
confirmed_more=pd.Series(confirmed.index)[count>Iran_days_infection-1]
confirmed_more.drop(index=confirmed_more.index[confirmed_more=='China'],inplace=True)
confirmed_more.drop(index=confirmed_more.index[confirmed_more=='Cruise Ship'],inplace=True)
#Prepare a matrix to store the rate of infection
signal=np.empty((len(confirmed_more),Iran_days_infection))

fig = go.Figure()

# Add traces
counter=-1
for co in confirmed_more:
 counter+=1
 l=pd.Series(confirmed.index)==co
 l.index=confirmed.index
 profile_c=confirmed.loc[l].values[0]
 #some of the countries did not declare any confirmed cases at 1/24/2020. This if statement tries to find the first day of infecton in each country. 
 if len(np.where(profile_c==0)[0])==0:
  start=0
 elif len(np.where(profile_c==0)[0])>0 and np.where(profile_c==0)[0][0]>0:
   start=0
 else:
  start=np.where(profile_c==0)[0][-1]+1
 #Compute the infection rate for each county since its first day of infection (start) until the last day of infection in Iran
 signal[counter,:]=confirmed.loc[confirmed.index==co].iloc[0].diff(1).iloc[start:start+Iran_days_infection]
 #Scatter plot in plotly
 fig.add_trace(go.Scatter(y=signal[counter,:],
                    mode='lines',
                    name=co,line=dict(color='rgb({},{},{})'.format(np.random.randint(255),np.random.randint(255),np.random.randint(255))),opacity=0.7))
 fig.update_layout(
    title="Infection rate for Iran versus other countries: First {} days".format(Iran_days_infection),
    xaxis_title='Days',yaxis_title='Number of new confirmed cases (day-to-day rate of infection)',
    font=dict(
        
        size=12,
        color="#7f7f7f"
    )
)
fig.show()

confirmed_except_china=confirmed.index.drop("China")
start_date_of_Iran=(np.where(confirmed_Ir.iloc[0]>0)[0])[0]
fig=go.Figure()
for co in confirmed_except_china:
  s=np.where(confirmed.index==co)[0]
  fig.add_trace(go.Scatter(x=confirmed.columns[start_date_of_Iran:],y=confirmed.iloc[s[0],start_date_of_Iran-1:],name=co,
                           line=dict(color="rgb({},{},{})".format(np.random.randint(255),np.random.randint(255),np.random.randint(255)))))  
fig.show()

"""Plot the day-to-day death rate for Iran and some other countries"""

#Get the countries except for China
death_more=pd.Series(death.index).loc[count>Iran_days_infection-1]
death_more.drop(index=death_more.index[death_more=='China'],inplace=True)
death_more.drop(index=death_more.index[death_more=='Cruise Ship'],inplace=True)
#Prepare a matrix to store the rate of infection
signal_d=np.empty((len(death_more),Iran_days_infection))

fig = go.Figure()

# Add traces
counter=-1
for co in death_more:
 counter+=1
 l=pd.Series(confirmed.index)==co
 l.index=confirmed.index
 profile_c=confirmed.loc[l].values[0]
 #some of the countries did not declare any confirmed cases at 1/24/2020. This if statement tries to find the first day of infecton in each country. 
 if len(np.where(profile_c==0)[0])==0:
  start=0
 elif len(np.where(profile_c==0)[0])>0 and np.where(profile_c==0)[0][0]>0:
   start=0
 else:
  start=np.where(profile_c==0)[0][-1]+1
 #Compute the infection rate for each county since its first day of infection (start) until the last day of infection in Iran
 signal_d[counter,:]=death.loc[death.index==co].iloc[0].diff(1).iloc[start:start+Iran_days_infection]
 #Scatter plot in plotly
 fig.add_trace(go.Scatter(y=signal_d[counter,:],
                    mode='lines',
                    name=co,line=dict(color='rgb({},{},{})'.format(np.random.randint(255),np.random.randint(255),np.random.randint(255))),opacity=0.7))
 fig.update_layout(
    title="Death rate for Iran versus other countries: First {} days".format(Iran_days_infection),
    xaxis_title='Days',yaxis_title='Number of new died patients (day-to-day rate of death)',
    font=dict(
        
        size=12,
        color="#7f7f7f"
    )
)
fig.show()

"""Compare the number of new recovered patients"""

#Get the countries except for China
recover_more=pd.Series(recover.index).loc[count>Iran_days_infection-1]
recover_more.drop(index=recover_more.index[recover_more=='China'],inplace=True)
recover_more.drop(index=recover_more.index[recover_more=='Cruise Ship'],inplace=True)
#Prepare a matrix to store the rate of infection
signal_r=np.empty((len(recover_more),Iran_days_infection))

fig = go.Figure()

# Add traces
counter=-1
for co in recover_more:
 counter+=1
 l=pd.Series(confirmed.index)==co
 l.index=confirmed.index
 profile_c=confirmed.loc[l].values[0]
 #some of the countries did not declare any confirmed cases at 1/24/2020. This if statement tries to find the first day of infecton in each country. 
 if len(np.where(profile_c==0)[0])==0:
  start=0
 elif len(np.where(profile_c==0)[0])>0 and np.where(profile_c==0)[0][0]>0:
   start=0
 else:
  start=np.where(profile_c==0)[0][-1]+1
 #Compute the infection rate for each county since its first day of infection (start) until the last day of infection in Iran
 signal_r[counter,:]=recover.loc[recover.index==co].iloc[0].diff(1).iloc[start:start+Iran_days_infection]
 #Scatter plot in plotly
 fig.add_trace(go.Scatter(y=signal_r[counter,:],
                    mode='lines',
                    name=co,line=dict(color='rgb({},{},{})'.format(np.random.randint(255),np.random.randint(255),np.random.randint(255))),opacity=0.7))
 fig.update_layout(
    title="Recovery rate for Iran versus other countries: First {} days".format(Iran_days_infection),
    xaxis_title='Days',yaxis_title='Number of new recovered patients (day-to-day rate of recovery)',
    font=dict(
        
        size=12,
        color="#7f7f7f"
    )
)
fig.show()

"""Proportion of deaths to confirmed cases"""

fig = go.Figure()
signal_d_c=[]
#signal_r_c=[]
Stt=[]
Con=[]
counter=-1
for co in confirmed_more:
 counter+=1
 l=pd.Series(confirmed.index)==co
 l.index=confirmed.index
 profile_c=confirmed.loc[l].values[0]
 d=pd.Series(death.index)==co
 d.index=death.index
 profile_d=death.loc[d].values[0]
 r=pd.Series(recover.index)==co
 r.index=recover.index
 profile_r=recover.loc[d].values[0]
 if len(np.where(profile_c==0)[0])==0:
  start=0
 elif len(np.where(profile_c==0)[0])>0 and np.where(profile_c==0)[0][0]>0:
   start=0
 else:
  start=np.where(profile_c==0)[0][-1]+1
 Stt.append(start)
 signal_d_c.append(profile_d[start:]/profile_c[start:])
 #signal_r_c.append(profile_r[start:]/profile_c[start:])
 index_of_county=np.where(confirmed_more==co)[0][0]
 fig.add_trace(go.Scatter(x=list(range(Stt[index_of_county],Stt[index_of_county]+len(signal_d_c[index_of_county]))),y=signal_d_c[index_of_county],
                    mode='lines',
                    name=co,line=dict(color='rgb({},{},{})'.format(np.random.randint(255),np.random.randint(255),np.random.randint(255))),opacity=0.7))
 fig.update_layout(
    title="Proportion of Deaths to confirmed cases ",
    xaxis_title='Days',yaxis_title='Death to confirmed',
    font=dict(
        
        size=12,
        color="#7f7f7f"
    ),
    xaxis = dict(
        tickmode = 'array',
        tickvals = list(range(Stt[index_of_county],Stt[index_of_county]+len(signal_d_c[index_of_county]))),
        ticktext = death.columns,
        tickangle=-90,
    )
)
fig.show()

"""***Death growth factor***
The formula used is every day's new deaths / new deaths on the previous day. A growth factor larger than one is a sign of increase. 
A growth factor below 1 or a decreasing growth factor above one is a positive sign. A constantly increasing growth factor above one is a negatve sign of exponential growth. 
https://www.worldometers.info/coronavirus/coronavirus-death-toll/
"""

country='Iran'#you can choose a different country
death_dg=death[death.index==country]
if len(np.where(death_dg.iloc[0]==0)[0])==0:
  start=0
elif len(np.where(death_dg.iloc[0]==0)[0])>0 and np.where(death_dg.iloc[0]==0)[0][0]>0:
   start=0
else:
  start=np.where(death_dg.iloc[0]==0)[0][-1]+1

fig = go.Figure()
y=death_dg.iloc[0][start:]
dg=y.diff(1)[1:]/y.diff(1)[1:].shift(1)
fig.add_trace(go.Scatter(x=y.index,y=dg,
                    mode='lines+markers',
                    name=country,line=dict(color='red'),opacity=0.7))
fig.add_trace(go.Scatter(x=y.index,y=[1]*len(y),
                    mode='lines',showlegend=False
                    ,line=dict(color='black'),opacity=0.7))
fig.update_layout(
    title="Death growth factor plot",
    xaxis_title='Days',yaxis_title='Death growth',
    font=dict(
        
        size=12,
        color="#7f7f7f"
    )

)

"""The death growth factor had been decreasing for several days. It even got lower than one, which seems like a glimpse of hope.

# PREDICTION

This subsecton tries to provide a predictive model for the numebr of confirmed died cases for all countries. (You can select the county)

statsmodels is a great library for time series data analysis in python. Since the signal (number of confirmed cases) has an exponential growth, it does not seem to be stationary. To attain stationarity, we can first compute the difference between confirmed cases in two consecutive days (day-to-day infection rate), then we can fit an autoregressive model to the resulting variable. 
A one-step ahead prediction model is suggested to use.
"""

country=input('Enter the name of the country and press enter: ')

from statsmodels.tsa.arima_model import ARMA, ARIMA
#Choose the country
country=country
#find the signal
signalo=confirmed[confirmed.index==country]

if np.sum(signalo.iloc[0]==0)==0:
  start=0
elif np.sum(signalo.iloc[0]==0)>0 and np.where(signalo.iloc[0]==0)[0][0]>0:
   start=0
else:
  start=np.where(signalo.iloc[0]==0)[0][-1]+1
#get the numbers 
signal=signalo.iloc[0][start:]

"""***The way that the model works is that it takes the first 'st' observations and fits an ARIMA(p=1,d=1) model (to the rate not the actual observations). After fitting the model, it makes a prediction for the next day. Then the model takes the first st+1 observations, fits the ARIMA model and predicts the next day again. This procedure is repeated until there is no observation left in the signal. The model is updated every day. A very important point to note is that if the authorities exert any novel strategy, then these models most likely will no longer be able to predict correcltly (hopefully this will happen in our country)***"""

pred=[]
lower_limit=[]
upper_limit=[]
signal.index=range(len(signal))
st=8
counter=-1
for k in range(st,len(signal)+1):
 counter+=1
 fitar=ARIMA(signal[:k],(1,1,0))
 fittedar=fitar.fit()
 pred.append(fittedar.forecast(1)[0][0])
 lower_limit.append(pred[counter]-1.96*np.sqrt(fittedar.sigma2))
 upper_limit.append(pred[counter]+1.96*np.sqrt(fittedar.sigma2))

"""The following line gives the coefficients"""

fittedar.params

"""Plot the predicted versus actual observations"""

fig=go.Figure()
fig.add_trace(go.Scatter(y=signal[st:], mode='lines+markers',name='True signal',line=dict(color='red'),opacity=0.7))
fig.add_trace(go.Scatter(y=pred,mode='lines+markers',name='Predicted signal',line=dict(color='blue'),opacity=0.7))

fig.update_layout(
    title="One-step ahead prediction for the number of confirmed cases in {}".format(country),
    xaxis_title='Days',yaxis_title='Number of confirmed cases',
    font=dict(
        
        size=12,
        color="#7f7f7f"
    ),
    xaxis = dict(
        tickmode = 'array',
        tickvals = np.arange(len(signal[st:])),
        ticktext = signalo.columns[start+st:],
        tickangle=-90,
    )
)

"""Show a 95% probability limit for the predicted values"""

fig=go.Figure()
fig.add_trace(go.Scatter(y=pred,mode='lines+markers',name='Predicted signal',line=dict(color='blue'),opacity=0.7))
fig.add_trace(go.Scatter(y=lower_limit,mode='lines',fill='tonexty',name='Probability Limits',line=dict(color='pink'),opacity=0.4))
fig.add_trace(go.Scatter(y=upper_limit,mode='lines',fill='tonexty',name='Probability Limits',line=dict(color='pink'),opacity=0.4,showlegend=False))

fig.update_layout(
    title="One-step ahead prediction for the number of confirmed cases in {}".format(country),
    xaxis_title='Days',yaxis_title='Number of confirmed cases',
    font=dict(
        
        size=12,
        color="#7f7f7f"
    ),
    xaxis = dict(
        tickmode = 'array',
        tickvals = np.arange(len(signal[st:])),
        ticktext = signalo.columns[start+st:],
        tickangle=90,
    )
)

"""The following codes can predict the number of deaths in the countries

Run the following code and enter your country:
"""

country=input('Enter the name of the country and press enter: ')

from statsmodels.tsa.arima_model import ARMA, ARIMA
#Choose the country
country=country
#find the signal
signalo_d=death[death.index==country]

if np.sum(signalo_d.iloc[0]==0)==0:
  start_d=0
elif np.sum(signalo_d.iloc[0]==0)>0 and np.where(signalo_d.iloc[0]==0)[0][0]>0:
   start_d=0
else:
  start_d=np.where(signalo_d.iloc[0]==0)[0][-1]+1
#get the numbers 
signal_d=signalo_d.iloc[0][start_d:]

pred_d=[]
lower_limit_d=[]
upper_limit_d=[]
signal_d.index=range(len(signal_d))
st_d=11
counter=-1
for k in range(st_d,len(signal_d)+1):
 counter+=1
 fitar_d=ARIMA(signal_d[:k],(1,2,0))
 fittedar_d=fitar_d.fit(method='css-mle')
 pred_d.append(fittedar_d.forecast(1)[0][0])
 lower_limit_d.append(pred_d[counter]-1.96*np.sqrt(fittedar_d.sigma2))
 upper_limit_d.append(pred_d[counter]+1.96*np.sqrt(fittedar_d.sigma2))

fittedar_d.params

fig=go.Figure()
fig.add_trace(go.Scatter(y=pred_d,mode='lines+markers',name='Predicted signal',line=dict(color='blue'),opacity=0.7))
fig.add_trace(go.Scatter(y=signal_d[st_d:],mode='lines+markers',name='Actual signal',line=dict(color='red'),opacity=0.7))
fig.update_layout(
    title="One-step ahead prediction for the number of deaths in {}".format(country),
    xaxis_title='Days',yaxis_title='Number of deaths',
    font=dict(
        
        size=12,
        color="#7f7f7f"
    ),
    xaxis = dict(
        tickmode = 'array',
        tickvals = np.arange(len(signal_d[st_d:])),
        ticktext = signalo_d.columns[start_d+st_d:],
        tickangle=-45,
    )
)

"""The following plot gives a control chart for statistiically monitoring the prediction error. Points beyounds the limits show a statistically significant change in the system. In other words, there might be an assignable cause shifting changing the condition in the outside world. See Italy for example."""

fig=go.Figure()
fig.add_trace(go.Scatter(y=signal_d[st_d:]-pred_d[:-1],mode='lines+markers',name='Error',line=dict(color='blue'),opacity=0.7))
fig.add_trace(go.Scatter(y=[2.8*np.sqrt(fittedar_d.sigma2)]*len(signal_d[st_d:]),
                    mode='lines',showlegend=False
                    ,line=dict(color='red'),opacity=0.7))
fig.add_trace(go.Scatter(y=[-2.8*np.sqrt(fittedar_d.sigma2)]*len(signal_d[st_d:]),
                    mode='lines',showlegend=False
                    ,line=dict(color='red'),opacity=0.7))

fig.update_layout(
    title="Control chart for montoring the number of deaths predictioin error in {}".format(country),
    xaxis_title='Days',yaxis_title='Residual Errors',
    font=dict(
        
        size=12,
        color="#7f7f7f"
    ),
    xaxis = dict(
        tickmode = 'array',
        tickvals = np.arange(len(signal_d[st_d:])),
        ticktext = signalo_d.columns[start_d+st_d:],
        tickangle=-45,
    )
)